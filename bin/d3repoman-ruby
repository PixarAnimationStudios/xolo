#!/usr/bin/ruby

require 'open3'
require 'yaml'
require 'pathname'
require 'tempfile'
require 'thread'

# This app runs forever and records timestamps when apps come to the foreground
#
# TODO Report errors somewhere
#
class RepoMan

  LSAPPINFO_CMD = '/usr/bin/lsappinfo listen +becameFrontmost forever'.freeze
  NOTIFICATION_START = 'Notification: kLSNotifyBecameFrontmost'.freeze
  NOTIFICATION_BUNDLE_ID_RE = /"CFBundleIdentifier"="(.+?)"/
  REPOMAN_DIR = Pathname.new '/Library/Application Support/d3/Usage/'

  # Set up - load in the existing usage data
  # This is the only time it's read, after this, it's only written.
  def initialize
    @repoman_file = REPOMAN_DIR + "#{ENV['USER']}.yml"
    @update_mutex = Mutex.new
    @usage = @repoman_file.file? ? YAML.load(@repoman_file.read) : {}
  end # init

  # Start lsappinfo in another thread, and react to its notifications
  #
  def run
    Open3.popen3(LSAPPINFO_CMD) do |_stdin, stdout, _stderr, _wait_thr|
      while (notif = stdout.gets)
        handle_a_notification notif
      end # while
    end # open3
  end # run

  # this parses the text of the notification
  # The mutex protects from fast notifications stomping each other.
  def handle_a_notification(notif)
    return unless notif.start_with? NOTIFICATION_START
    @update_mutex.synchronize do
      notif =~ NOTIFICATION_BUNDLE_ID_RE
      bundle_id = Regexp.last_match(1)
      return unless bundle_id
      @usage[bundle_id] = Time.now
      puts "Looks like #{ENV['USER']} brought #{bundle_id} forward at #{@usage[bundle_id]}"
      # save_usage
    end # mutex sync
  end # handle_a_notification

  # This updates the file atomically, by writing to a tmp file
  # and moving/renaming it into place in one step
  def save_usage
    tmpf = Pathname.new(Dir::Tmpname.create('') { |path| path })
    tmpf.open('w+') { |f| f.write YAML.dump(@usage) }
    tmpf.rename @repoman_file
  end

end # class RepoMan

RepoMan.new.run
