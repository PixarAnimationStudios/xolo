#!/usr/bin/ruby
#
# This script is designed to be run from a policy via Self Service.
#
# If you want a tool to install d3 packages from the command-line,
# or without user-interaction, there already is one, it's called 'd3' ;-)
# (See 'AUTOMATED D3 INSTALLS VIA POLICIES' below)
#
# While generally you'll use this to install a single d3 package, it can
# install up to 8, or 6 if you use both notifier options.
#
# When you add this script to a policy, fill the script parameters with
# d3 basenames or editions to be installed. Use one basename or edition
# per parameter.
#
# if you provide '--dialog' in any parameter, a notification dialog will appear
# when all installations are finished.
#
# If you provide '--reveal=/path/to/a/thing' in any parameter,
# then when all installations are finished, the item at /path/to/a/thing will be
# revealed in the Finder, if it exists.
#
# -- Reboots
#
# If a pkg being installed requires a reboot, the user is warned that if
# they procede the machine WILL reboot. After installation, a dialog appears
# givein them 5 minutes, or until the dialog is dismissed, before the
# machine reboots.
#
# NOTE: Setting the policy itself to reboot is not necessary. This script
# will perform a normal (non-authenticated) restart if a package requires one.
# Since this script only runs with user-interaction, the user is likely to be
# there to authenticate to Filevault if needed.
#
# If a reboot is required, --dialog and --reveal= are ignored.
#
# The parameters can be in any order, tho if you're installing more than one
# d3 pkg, the installs will happen in the order given.
#
# -- AUTOMATED D3 INSTALLS VIA POLICIES --
#
# If you need to install something with d3 via a policy, without user
# interaction just do this:
#
# - Edit your policy
# - In the sidebar, choose the 'Files and Processes' section
# - Click the 'Configure' button if no other options are configured
# - At the bottom of the pane, edit the 'Execute Command' field
# - Enter the 'd3 install' command exactly as you would type it in a terminal
# --  Remember to use to --admin option. It's best to use some text
#     that indicates how the item was installed, e.g. 'policy-foobar'
# - Set other policy options as desired (scope, triggers, etc)
# - Save your policy.
# If the d3 installs are having problems, look at the policy logs in
# Jamf Pro. If needed, add the --debug option to the d3 command for more
# details.
#
# -- WHY NOT JUST MAKE THE POLICY INSTALL THE PACKAGE? --
#
# Yes, it's true that d3 packages are just Jamf packages, and as such you
# could just have a policy directly install them without calling d3.
#
# The reason this isn't recommended is: when a pkg is installed that
# way, d3 doesn't have control of the package on the client machine and
# the advatanges d3 provides won't be available (auto updates, reporting
# who/what did the installation, etc.)
# As a general rule, if you put a pkg into d3, you should always use d3
# and d3admin to work with that package.

require 'd3'

# the app object
class App

  # this is appended to the username of the user running Self Service
  D3_INSTALL_ADMIN_PREFIX = 'selfsvc'.freeze

  # The genearl Self Service icon for dialogs
  SS_ICON = Pathname.new '/Applications/Utilities/Self Service.app/Contents/Resources/Self Service.icns'

  # An icon for error dialogs
  ERROR_ICON = Pathname.new '/Applications/Utilities/Self Service.app/Contents/Resources/StopSign.png'

  # If the args contain this a match for this, then $1 is a path to be revealed in the Finder
  # after installation.
  NOTIFY_REVEAL = '--reveal='.freeze

  # if the args contain this, then a notification dialog is displayed
  # after installation
  NOTIFY_DIALOG = '--dialog'.freeze

  ############## Setup
  def initialize(args)
    Xolo::Client.connect

    # Only send to stdout/stderr if there's a fatal error.
    Xolo.verbosity = :fatal

    # since this is running via a Jamf Policy,
    # args 0, 1, and 2 are used for other things we
    # don't care about.
    # Anything else in the args are basenames or editions
    # to be installed via d3, or notification options
    3.times { args.shift }

    # notification dialog?
    if args.include? NOTIFY_DIALOG
      @notify_dialog = true
      args.delete NOTIFY_DIALOG
    end

    # if revealing, extract the path from the args
    reveal_arg = args.select { |a| a.start_with? NOTIFY_REVEAL }.first
    if reveal_arg
      @notify_reveal = true
      @item_to_reveal = Pathname.new reveal_arg[NOTIFY_REVEAL.length..-1]
      args.delete reveal_arg
    end

    # remove any empty/nil args
    @items_to_install = args.reject { |a| a.to_s.empty? }
  end # init

  ############## Run
  def run
    return if @items_to_install.empty?

    begin
      @items_to_install.each { |item| install item }

      # if any installed pkgs need a reboot, this was set to true
      if @need_reboot
        reboot
        return
      end

      # if any install was successful, notify if requested
      notify if @need_notify

    rescue Xolo::SelfServiceError => err
      display_error err
    end
  end # run

  ### Instance Methods
  ############################################

  # Display Error to the user
  #
  # @param exception[Exception] the Ruby exception to display
  #
  # @return [void]
  #
  def display_error(exception)
    JSS::Client.jamf_helper(
      :utility,
      title: 'ERROR - Oh Noes!',
      heading: 'An Error occured during installation. Please report this.',
      description: exception.to_s,
      icon: ERROR_ICON,
      button1: 'OK',
      default_button: 1
    )
  end # End display_error

  # Install a basename or edition, getting any needed user approval
  # along the way
  #
  # @param item[String] The basename or edition to install
  #
  # @return [void]
  #
  def install(item)
    pkg = pkg_from_item item

    current_rcpt = Xolo::Client::Receipt.all[pkg.basename]
    if current_rcpt
      return unless reinstall_ok? pkg, current_rcpt
      return unless downgrade_ok? pkg, current_rcpt
    end

    return unless reboot_ok? pkg

    begin
      pkg.install admin: "#{D3_INSTALL_ADMIN_PREFIX}-#{ENV['USER']}", puppywalk: true, force: true
    rescue => err
      raise Xolo::SelfServiceError, "#{err.class}: #{$ERROR_INFO}"
    end
    @need_reboot ||= pkg.reboot?
    @need_notify = true
  end

  # Given a basename or edition, get the Xolo::Package object
  #
  # @param item[String] a basename or edition
  #
  # @return [Xolo::Package] the matching package object
  #
  def pkg_from_item(item)
    if Xolo::Package.all_basenames.include? item
      Xolo::Package.new basename: item
    elsif Xolo::Package.all_editions.include? item
      Xolo::Package.new edition: item
    else
      raise Xolo::SelfServiceError, "The item '#{item}' isn't available in d3."
    end
  end

  # Is it OK to install this if it's a re-install?
  # Always true unless the pkg and Receipt ids are the same
  # in which case we ask the user.
  #
  # @param pkg[Xolo::Package] The pkg to install
  #
  # @param rcpt[Xolo::Client::Receipt] The matching Receipt
  #
  # @return [Boolean] Is it ok to install?
  #
  def reinstall_ok?(pkg, rcpt)
    return true unless pkg.id == rcpt.id
    title = "Re-Install #{rcpt.edition}"
    msg = "Looks like #{rcpt.edition} is already installed.\nRe-install it?"
    user_ok? title, msg
  end

  # Is it OK to install this if it's a downgrade?
  # Always true unless the pkg id is lower than the rcpt id
  # in which case we ask the user.
  #
  # @param pkg[Xolo::Package] The pkg to install
  #
  # @param rcpt[Xolo::Client::Receipt] The matching Receipt
  #
  # @return [Boolean] Is it ok to install?
  #
  def downgrade_ok?(pkg, rcpt)
    return true unless pkg.id < rcpt.id
    title = "Downgrade to #{pkg.edition}"
    msg = "You have #{rcpt.edition} installed.\nDowngrade to #{pkg.edition}?"
    user_ok? title, msg
  end

  # Is it OK to install knowing that we WILL reboot at the end?
  # always ask the user. Always true if no reboot needed
  #
  # @param pkg[Xolo::Package] The pkg to install
  #  #
  # @return [Boolean] Is it ok to install & reboot?
  #
  def reboot_ok?(pkg)
    return true unless pkg.reboot?
    title = 'REBOOT REQUIRED'
    msg = "WARNING!!!\n#{pkg.edition} requires a reboot after installation.\nClicking OK *WILL* reboot this computer,\nReally install it and reboot?"
    user_ok? title, msg
  end

  # Present a dialog to the user and return true if they click OK
  # false otherwise
  #
  # @param title[String] The dialog title
  #
  # @param msg[String] The dialog Message
  #
  # @return [Boolean] Did they click OK?
  #
  def user_ok?(title, msg)
    JSS::Client.jamf_helper(
      :utility,
      title: title,
      description: msg,
      icon: SS_ICON,
      button1: 'OK',
      button2: 'Cancel',
      default_button: 2,
      cancel_button: 2
    ).zero?
  end

  # Give the user up to 5 min before rebooting
  #
  # @return [void]
  #
  def reboot
    JSS::Client.jamf_helper(
      :utility,
      title: 'Rebooting',
      description: "This computer will reboot in 5 minutes,\nor when you click a button",
      icon: SS_ICON,
      button1: 'Reboot Now',
      button2: 'Restart Now',
      timeout: 300,
      countdown: true
    )
    system '/sbin/shutdown -r now'
  end

  # Do some kind of notification if any was requested
  #
  # @return [void]
  #
  def notify
    notify_dialog if @notify_dialog
    notify_reveal if @notify_reveal
  end

  # Display a dialog saying we're done.
  #
  # @return [void]
  #
  def notify_dialog
    JSS::Client.jamf_helper(
      :utility,
      title: 'All Done!',
      heading: 'Installation has finished',
      description: "You installed: #{@items_to_install.join ', '}",
      icon: SS_ICON,
      button1: 'OK',
      timeout: 300
    )
  end

  # If we were given a path to reveal in the Finder,
  # do so after confirming it exists.
  #
  # @return [void]
  #
  def notify_reveal
    return unless @item_to_reveal.exist?
    ascript = "tell application \"Finder\" to reveal (POSIX file \"#{@item_to_reveal}\") as alias"
    system "/usr/bin/osascript -e #{Shellwords.escape ascript} -e 'tell application \"Finder\" to activate' "
  end

end # class App

#################  The main block  #########################
if $PROGRAM_NAME == __FILE__
  begin
    app = App.new(ARGV)
    app.run
    exit 0
  rescue => the_exception
    $stderr.puts "An error occurred: #{the_exception.message}"
    $stderr.puts the_exception.backtrace
    exit 1
  end # begin
end # if $PROGRAM_NAME == __FILE__
