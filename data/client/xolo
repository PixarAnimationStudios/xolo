#!/bin/zsh

# Copyright 2024 Pixar
#
#    Licensed under the Apache License, Version 2.0 (the "Apache License")
#    with the following modification; you may not use this file except in
#    compliance with the Apache License and the following modification to it:
#    Section 6. Trademarks. is deleted and replaced with:
#
#    6. Trademarks. This License does not grant permission to use the trade
#       names, trademarks, service marks, or product names of the Licensor
#       and its affiliates, except as required to comply with Section 4(c) of
#       the License and to reproduce the content of the NOTICE file.
#
#    You may obtain a copy of the Apache License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the Apache License with the above modification is
#    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#    KIND, either express or implied. See the Apache License for the specific
#    language governing permissions and limitations under the Apache License.

# SHELL SETUP
###############################
###############################

# Load the zsh/zutil module for several utility functions
zmodload zsh/zutil

# for perl-style regexps
setopt RE_MATCH_PCRE

# ENVIRONMENT
###############################
###############################

# Needed for the UTF-8 chars in the lsreg output
export LANG="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

# CONSTANTS
###############################
###############################

# The list of commands that xolo can accept
COMMANDS=(
  install i
  uninstall u
  refresh r
  titles t
  list l
  details d
  expire e
)

# The usage message for xolo
USAGE='xolo [options] <command> [<title> [<version>]]'

# The URL for more information about xolo
XOLO_DOX_URL='<URL TO BE DETERMINED>'

# The long path to the lsregister command
LSREG='/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister'

# The path to the jamf binary
JAMF='/usr/local/bin/jamf'

# The path to the client data json file
CLIENT_DATA_JSON_FILE="/Library/Application Support/xolo/client-data.json"

# The jamf policy trigger to update the client data
UPDATE_CLIENT_DATA_TRIGGER='update-xolo-client-data'

# GLOBAL VARIABLES
###############################
###############################

# From the command line
show_help=
be_verbose=
be_quiet=
debugging_on=
command=
title=
version=

# An Associative Array to hold the installed apps
typeset -A installed_apps

# FUNCTIONS
###############################
###############################

# Print a message to stderr
###############################
function echoerr() { echo "$@" 1>&2; }

# Die with an error message and status
###############################
function die() {
  local msg="$1"
  local mystat=1
  [[ -n "$2" ]] && mystat=$2
  echoerr "$msg"
  exit $mystat
}


# Show the help message
###############################
function show_help() {
  cat <<ENDHELP
xolo: manage software titles on this computer

Usage:
  $USAGE

Options:
  -h, -H, --help: Show this help message.
  -v, --verbose: Enable verbose mode, extra information will be printed.
  -q, --quiet: Enable quiet mode, only errors will be printed to stderr.
  -d, --debug: Enable debug mode, extra debug information will be printed.

  NOTE: Debug mode will also enable verbose mode. Both debug and verbose modes
  override quiet mode.

Commands:
  install, i <title> [<version>]
    Install a title, or specific version thereof (e.g. a version currently in pilot)
    If no version is specified, the currently released version will be installed.

  uninstall, u <title>
    Uninstall a title, if possible. Not all titles are uninstallable via xolo.

  refresh, r
    Update xolo's information about current titles and versions.
    This also happens automatically at least daily, when this computer is online.

  titles, t
    List all known titles and versions. Not all may be available for install,
    e.g., if this computer is in an excluded computer-group

  list, l
    List titles installed on this computer, that are known to xolo.

  details, d <title> [<version>]
    Show detailed information about a title, or a specific version thereof.

  expire, e
    Expire any expirable titles that have not been used in their defined expiration period,
    This also happens automatically at least daily.

  For more information about xolo, see $XOLO_DOX_URL
ENDHELP
} # end show_help

# Parse the command line arguments
###############################
function parse_cli() {
  zparseopts -D -F -E -- \
    {h,H,-help}=show_help \
    {v,-verbose}=be_verbose \
    {q,-quiet}=be_quiet \
    {d,-debug}=debugging_on || \
    die 'Unknonwn Options or Args.'

  # they are in arrays, but we want regular vars
  show_help=$show_help[-1]
  be_verbose=$be_verbose[-1]
  be_quiet=$be_quiet[-1]
  debugging_on=$debugging_on[-1]



  # if debugging is on, verbose is also on
  [[ -n $debugging_on ]] && be_verbose=1

  # if we're in verbose mode, we're not in quiet mode
  [[ -n $be_verbose ]] && unset be_quiet

  command=$1
  [[ ${#@} -gt 0 ]] && shift

  title=$1
  [[ ${#@} -gt 0 ]] && shift

  version=$1

  # echo "show_help is: $show_help"
  # echo "be_verbose is: $be_verbose"
  # echo "be_quiet is: $be_quiet"
  # echo "debugging_on is: $debugging_on"
  # echo "command is: $command"
  # echo "title is: $title"
  # echo "version is: $version"


  debug "Parsed command line:"
  debug "..show_help is: $show_help"
  debug "..be_verbose is: $be_verbose"
  debug "..be_quiet is: $be_quiet"
  debug "..debugging_on is: $debugging_on"
  debug "..command is: $command"
  debug "..title is: $title"
  debug "..version is: $version"
}

# quick test for debugging_on
###############################
function debugging_on() {
  [[ -n "$debugging_on" ]]
}

# quick test for be_verbose
###############################
function be_verbose() {
  [[ -n "$be_verbose" ]]
}

# quick test for be_quiet
###############################
function be_quiet() {
  [[ -n "$be_quiet" ]]
}

# Print a message to stout if we're not in quiet mode
###############################
function say() {
  be_quiet || echo "$*"
}

# Print a message to stdout if we're in verbose mode
###############################
function verbose() {
  be_verbose && echo "$*"
}

# Print a debug message to stderr if debugging is on
###############################
function debug() {
  debugging_on && echo "DEBUG: $*" 1>&2
}

# what to tack on to the end of a jamf policy command
###############################
function jamf_policy_modifier() {
  if be_verbose ; then
    echo '-verbose'
  elif be_quiet ; then
    echo '> /dev/null'
  fi
}

# Gather all installed bundle ids and app names from lsreg
# store them in an associative array in $installed_apps.
# keys are bundle ids, values are app names
###############################
function get_installed_apps() {
  # loop thru lsreg output
  "$LSREG" -dump Bundle | while IFS= read -r line ; do
    # a line if ------ starts a new record
    if [[ "$line" =~ '^-+$' ]] ; then
      unset app_name
      unset app_bundle_id
      continue
    fi

    # $MATCH is the whole matched string, $match is the array of captures
    [[ "$line" =~ '^path:\s+/.*/(.+\.app) \(' ]] && app_name=$match[1]
    [[ "$line" =~ '^\s+CFBundleIdentifier = "(.+)";' ]] && app_bundle_id=$match[1]

    if [[ -n "$app_name" && -n "$app_bundle_id" ]] ; then
      installed_apps[$app_bundle_id]=$app_name
      unset app_name
      unset app_bundle_id
    fi
  done
  # installed_apps is now an associative array with bundle ids as keys and app names as values

  # TMP: print the installed apps
  for bundle app in ${(kv)installed_apps}; do
        echo "$bundle -> $app"
  done

} # end installed_apps


# $1 = a string of javascript that extracts your desired info from
# the client-data.json file, which has already been parsed into
# the variable 'parsed_data'
#
# your code should process parsed_data however it needs, and then
# put the desired output string  into the 'result' var, which has already
# been declared.
#
# The result of your processing will be sent to stdout of this function
#######################################
function extract_json_data() {
  local processing_code="$1"
  local CLIENT_DATA_PROCESSING_JS

  read -r -d '' CLIENT_DATA_PROCESSING_JS <<ENDJAVASCRIPT
// this gives us access to the local file system
var app = Application.currentApplication();
app.includeStandardAdditions = true;

// run() is automatically executed when the program is called, and will print any output returned.
function run() {
    var parsed_data = JSON.parse(app.read("${CLIENT_DATA_JSON_FILE}"));
    var result;

    // the line below will sub-in whatever code we were passed
    // to process the parsed data and store the result in 'result'

    ${processing_code}

    return result
}
ENDJAVASCRIPT

  # echo '========================'
  # echo "${CLIENT_DATA_PROCESSING_JS}"
  # echo '========================'

  # run the javascript to send the result to stdout
  osascript -l "JavaScript" <<< "${CLIENT_DATA_PROCESSING_JS}"

}

# Outputs all known titles, one per line
#######################################
function all_xolo_titles() {
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
    result = Object.keys(parsed_data.titles).join('\n');
ENDJAVASCRIPT
  extract_json_data "$jscode"
}


# $1 = the name of a title
# Outputs all the versions for the title, one per line
#######################################
function versions_for_title() {
  local desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     result = parsed_data.titles["${desired_title}"]["version_order"].join('\n');
   } else {
     result = \`Unknown title \${desired_title}\n\`;
   }
ENDJAVASCRIPT
  extract_json_data "$jscode"
}

# $1 = the name of a title
# Output the text to be displayed for the 'details' command for a title
#######################################
function details_for_title() {
  desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var title_data = parsed_data.titles["${desired_title}"];

     result = \`Details of title \${title_data.title}\n\`;
     result += \`..Display Name: \${title_data.display_name}\n\`;
     result += \`..Description: \${title_data.description}\n\`;
     result += \`..Publisher: \${title_data.publisher}\n\`;
     result += \`..Release Groups: \${title_data.release_groups}\n\`;
     result += \`..Excluded Groups: \${title_data.excluded_groups}\n\`;

     if (title_data.uninstall_script || title_data.uninstall_ids.length > 0) {
       var uninstallable = 'true';
     } else {
       var uninstallable = 'false';
     }
     result += \`..Uninstallable: \${uninstallable}\n\`;

     if ( uninstallable == 'true' && title_data.expiration && title_data.expire_paths.length > 0) {
       result += \`..Expires after days of disuse: \${title_data.expiration}\n\`;
       result += \`..Expire Paths: \${title_data.expire_paths}\n\`;
     }

     if ( title_data.self_service ) {
      result += \`..In Self Service: true\n\`;
      result += \`..Self Service Category: \${title_data.self_service_category}\n\`;
     }

     result += \`..Contact: \${title_data.contact_email}\n\`;
     result += \`..Added to Xolo: \${title_data.creation_date} by \${title_data.created_by}\n\`;

     result += \`..Versions:\n\`;
     if (title_data.versions.length > 0) {
       title_data.versions.forEach(
         function (arrayItem) {
            result += \`....\${arrayItem.version}: \${arrayItem.status}\n\`;
          }
        );
      } else {
        result += \`....No versions added yet\n\`;
      }

   } else {
     result = \`Unknown title ${desired_title}\n\`;
   }
ENDJAVASCRIPT

  extract_json_data "$jscode"
}


# $1 = the name of a title
# $2 = the name of a version
# Output the text to be displayed for the 'details' command for a version
#######################################
function details_for_version() {
  desired_title=$1
  desired_version=$2
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var title_data = parsed_data.titles["${desired_title}"];
     var version_data = title_data.versions.find(
        function(value, index, array) {
          return value.version == "${desired_version}";
        }
      );

     if (version_data) {
         result = \`Details of version '\${version_data.version}' of title \${title_data.title}\n\`;
         result += \`..Publish Date: \${version_data.publish_date}\n\`;
         result += \`..Added to Xolo: \${version_data.creation_date} by \${version_data.created_by}\n\`;
         if (version_data.pilot_groups.length > 0) result += \`..Pilot Groups: \${version_data.pilot_groups}\n\`;

         result += \`..Minimum OS Version: \${version_data.min_os}\n\`;
         if (version_data.max_os) result += \`..Maximum OS Version: \${version_data.max_os}\n\`;
         result += \`..Requires Reboot: \${version_data.reboot}\n\`;
         result += \`..Standalone: \${version_data.standalone}\n\`;
         if (version_data.killapps.length > 0) result += \`..KillApps: \${version_data.killapps}\n\`;

         result += \`..Status: \${version_data.status}\n\`;
         if (version_data.status == 'released') {
           result += \`..Released: \${version_data.release_date} by \${version_data.released_by}\n\`;
           if (title_data.release_groups.length > 0)  result += \`..Release Groups: \${title_data.release_groups}\n\`;
         }

         if (version_data.status == 'deprecated') {
           result += \`..Deprecated: \${version_data.deprecation_date} by \${version_data.deprecated_by}\n\`;
         }

         if (version_data.status == 'skipped') {
           result += \`..Skipped: \${version_data.skipped_date} by \${version_data.skipped_by}\n\`;
         }



      } else {
        result = \`Unknown version '${desired_version}' for title ${desired_title}\`;
     }

   } else {
     result = \`Unknown title ${desired_title}\`;
   }
ENDJAVASCRIPT

  extract_json_data "$jscode"
}

# $1 = the name of a title
# Outputs the version script for the title
# or empty string if not set, or if no matching title
#######################################
function version_script_for_title() {
  desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var vscript = parsed_data.titles["${desired_title}"]["version_script"];
     result = vscript ? vscript : ''
   } else {
     result = '';
   }
ENDJAVASCRIPT
  extract_json_data "$jscode"
}

# $1 = the name of a title
# Outputs the app_name and app_bundle_id for the title, semi-colon separated
# or empty string if not set, or if no matching title
#######################################
function app_data_for_title() {
  desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var appname = parsed_data.titles["${desired_title}"]["app_name"];
     var bundleid = parsed_data.titles["${desired_title}"]["app_bundle_id"];
     if (appname && bundleid) {
      result = \`\${appname};\${bundleid} \`;
     } else {
       result = '';
     }
        } else {
     result = '';
   }
ENDJAVASCRIPT
  extract_json_data "$jscode"
}

# $1 = the name of a title
# Outputs the expiration period (integer of days) for the title
# or empty string if not set, or if no matching title
#######################################
function expiration_for_title() {
  desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var expiration = parsed_data.titles["${desired_title}"]["expiration"];
     result = expiration ? expiration : ''
   } else {
     result = '';
   }
ENDJAVASCRIPT
  extract_json_data "$jscode"
}

# $1 = the name of a title
# Outputs the expire paths for the title one per line
# or empty string if not set, or if no matching title
#######################################
function expire_paths_for_title() {
  desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var expire_paths = parsed_data.titles["${desired_title}"]["expire_paths"];
     result = expire_paths.length > 0 ? expire_paths.join("\n") : ''
   } else {
     result = '';
   }
ENDJAVASCRIPT
  extract_json_data "$jscode"
}

# $1 = the name of a title
# Outputs the currently released version for the title
# or empty string if not set, or if no matching title
#######################################
function released_version_for_title() {
  desired_title=$1
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var released_version = parsed_data.titles["${desired_title}"]["released_version"];
     result = released_version ? released_version : ''
   } else {
     result = '';
   }
ENDJAVASCRIPT
  extract_json_data "$jscode"
}

# $1 = the name of a title
# $2 = the name of a version
# Output status of a version
#######################################
function status_for_version() {
  desired_title=$1
  desired_version=$2
  local jscode

  read -r -d '' jscode <<ENDJAVASCRIPT
   if (parsed_data.titles["${desired_title}"]) {
     var title_data = parsed_data.titles["${desired_title}"];
     var version_data = title_data.versions.find(
        function(value, index, array) {
          return value.version == "${desired_version}";
        }
      );

     if (version_data) {
        result = version_data.status;
      } else {
        result = \`Unknown version '${desired_version}' for title ${desired_title}\`;
     }

   } else {
     result = \`Unknown title ${desired_title}\`;
   }
ENDJAVASCRIPT

  extract_json_data "$jscode"
}



# Refresh the client data
###############################
function refresh_client_data() {
  verbose "Refreshing client data..."

  cmd="$JAMF policy -trigger $UPDATE_CLIENT_DATA_TRIGGER $(jamf_policy_modifier)"
  debug "Running: $cmd"
  $cmd
}

# validate that the title exists
###############################
function validate_title() {
  # die if no title given
  [[ -z "$title" ]] && die "No title given.\nUsage: $USAGE\nUse --help for more information."

  # die if no such title
  # all titles in an array
  IFS=$'\n' all_titles=($(all_xolo_titles))

  # index will be zero if the title is not in the array
  [[ ${all_titles[(Ie)$title]} -eq 0 ]] && die "No such title: $title"
}

# validate that the version exists
###############################
function validate_version() {
  validate_title
  # die if no version given
  [[ -z "$version" ]] && die "No version given.\nUsage: $USAGE\nUse --help for more information."

  # die if no such version
  all_versions=$(versions_for_title $title)
  [[ $all_versions =~ (^|\n)$version($|\n) ]] || die "No such version: $version"
}

# Install a title, or a specific version thereof
###############################
function install() {
  validate_title

  # if no version is given, we'll find the current release
  if [[ -z "$version" ]] ; then
    version=$(released_version_for_title $title)
    [[ -z "$version" ]] && die "No current release for title: $title. Specify a version to install."
  fi
  validate_version

  # get the policy trigger for the desired version
  policy_trigger="xolo-${title}-${version}-manual-install"

  # run the policy trigger
  verbose "Installing version $version of title $title..."

  cmd="$JAMF policy -trigger $policy_trigger $(jamf_policy_modifier)"
  debug "Running: $cmd"
  $cmd
}

# Unnstall a title
# This might not do anything if the title is not uninstallable,
# or if the title is not installed
###############################
function uninstall() {
  validate_title

  # get the policy trigger for the desired version
  policy_trigger="xolo-${title}-uninstall"

  # run the policy trigger
  verbose "Attempting to uninstall title $title..."

  # TODO: look at the output of the policy run to see if it was successful
  # and report possible reasons for failure, esp if no policy was found for
  # the trigger
  cmd="$JAMF policy -trigger $policy_trigger $(jamf_policy_modifier)"
  debug "Running: $cmd"
  $cmd
}

# List all known titles and their versions and statuses
# TODO: make this faster, it queries the client data for each version
###############################
function list_all_titles() {
  verbose "Listing all known titles..."

  output=""
  while IFS= read -r ttl; do
     output="$output\n$ttl:"
    while IFS= read -r vers; do
      output="$output $vers ($(status_for_version $ttl $vers)),"
    done <<<"$(versions_for_title $ttl)"
    # remove the last char, either the : or the ,
    output=${output::-1}
  done <<<"$(all_xolo_titles)"
  echo "$output"
}

# Show detailed information about a title or a version thereof
###############################
function show_details() {
  validate_title

  if [[ -z "$version" ]] ; then
    details_for_title $title
  else
    validate_version
    details_for_version $title $version
  fi
}

# MAIN
###############################
###############################

# Parse the command line
parse_cli "$@"

# If the user asked for help, show it and exit
if [[ -n "$show_help" ]] ; then
  show_help
  exit 0
fi

[[ -z "$command" ]] && die "No command given.\nUsage: $USAGE\nUse --help for more information."
[[ ! " ${COMMANDS[@]} " == *" $command "* ]] && die "Unknown command: $command\nUsage: $USAGE\nUse --help for more information."

case "$command" in
  install|i)
    debug "running function 'install'"
    install
    ;;
  uninstall|u)
    debug "running function 'uninstall'"
    uninstall
    ;;
  refresh|r)
    debug "running function 'refresh_client_data'"
    refresh_client_data
    ;;
  titles|t)
    debug "running function 'list_all_titles'"
    list_all_titles
    ;;
  list|l)
    debug "running function 'list_installed_titles'"
    list_installed_titles
    ;;
  details|d)
    debug "running function 'show_details'"
    show_details
    ;;
  expire|e)
    debug "running function 'expire'"
    expire
    ;;
  *)
    die "Unknown command: $command\nUse --help for more information"
    ;;
esac