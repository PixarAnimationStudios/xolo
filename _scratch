#### build install run locally in pers gems
cd ~/git/gemdev/depot3/; rm depot3-*.gem; gem build depot3.gemspec; gem install depot3-*.gem -n ~/bin; ~/bin/d3admin -h

############ build, install & run server on host, install on o, install locally
export GEM_HOME=/Users/chrisl/personal-gems ; \
export GEM_PATH="$GEM_HOME:/Library/Ruby/Gems/2.3.0/" ; \
cd /Users/chrisl/git/gemdev/depot3/ ; \
rm depot3*.gem ; \
gem build depot3.gemspec ; \
echo ----- INSTALLING ON VADERCAN ; \
host=vadercan ; \
rput depot3*.gem $host /tmp/depot3.gem ;\
brute $host gem uninstall -a -x  depot3 -i /Library/Ruby/Gems/2.3.0 -n /usr/local/pixar/bin ; \
brute $host gem install /tmp/depot3.gem -i /Library/Ruby/Gems/2.3.0 -n /usr/local/pixar/bin --ignore-dependencies --no-doc ; \
brute $host /usr/local/pixar/bin/lcr com.pixar.d3server.plist ; \
echo ----- INSTALLING ON O ; \
host=o ; \
rput depot3*.gem $host /tmp/depot3.gem ;\
brute $host gem uninstall -a -x  depot3 -i /Library/Ruby/Gems/2.3.0 -n /usr/local/pixar/bin ; \
brute $host gem install /tmp/depot3.gem -i /Library/Ruby/Gems/2.3.0 -n /usr/local/pixar/bin --ignore-dependencies --no-doc ; \
echo ----- INSTALLING LOCALLY ; \
gem uninstall -a -x  depot3 -n ~/bin ; \
gem install depot3*.gem  -n ~/bin --ignore-dependencies --no-doc



############ server config

conf='
ssl_key: /Library/Server/d3/chook_cert_key_unl.pem
ssl_cert: /Library/Server/d3/chook_cert_chain.pem
ssl_verify: false
log_level: debug
client_acct: d3client
client_pw: /usr/local/pixar/sbin/goth d3client|
jamf_acct: d3server
jamf_pw: /usr/local/pixar/sbin/goth d3server|
admin_jamf_group: d3admins
master_dist_point_rw_pw: /usr/local/pixar/sbin/goth casperadmin|
'
echo "$conf" > /etc/d3-server.conf


################## set launchd on server

ldjob='<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.pixar.d3server</string>
  <key>RunAtLoad</key>
  <true/>
	<key>KeepAlive</key>
	<true/>
	<key>ProgramArguments</key>
	<array>
		<string>/usr/local/pixar/bin/d3server</string>
    <string>--production</string>
	</array>
  <key>EnvironmentVariables</key>
  <dict>
    <key>GEM_HOME</key>
    <string>/Library/Ruby/Gems/2.3.0</string>
    <key>GEM_PATH</key>
    <string>/Library/Ruby/Gems/2.3.0:/Library/Ruby/pixar/gems</string>
  </dict>
  <key>StandardOutPath</key>
  <string>/var/log/d3server.log</string>
  <key>StandardErrorPath</key>
  <string>/var/log/d3server.log</string>
</dict>
</plist>'

echo "$ldjob" > /Library/LaunchDaemons/com.pixar.d3server.plist
chmod 600 /Library/LaunchDaemons/com.pixar.d3server.plist


################  Using with curl

curl -u chrisl --insecure  -X POST -c -  'https://d3server.pixar.com/api/v1/session'

# cookies will show up in stdout , put the rack.session cookie into a var
session_cookie='xxxxxxx...'


# or in one command:
session_cookie=`curl -u chrisl --insecure  -X POST -c -  'https://localhost/api/v1/session/login/admin' | grep 'rack\.session' | cut -d$'\t' -f7`

# use it to send the next call:

curl --insecure -X GET \
--cookie "rack.session=$session_cookie" \
'https://localhost/api/v1/session/valid'

curl --insecure -X DELETE \
--cookie "rack.session=$session_cookie" \
'https://localhost/api/v1/session'


# Or use curl's cookie jar properly
curl -u chrisl --insecure  -X POST --cookie-jar /tmp/curlcooks  'https://d3server.pixar.com/api/v1/session'

# and futire curls can use the jar
curl --insecure  -X GET --cookie-jar /tmp/curlcooks  'https://d3server.pixar.com/api/v1/categories'


########################################################################
############################################################



########## playing/testing in irb

##############
#  Startup and connect

require 'd3/admin'
app = D3::AdminApp.new
app.connect

ARGV << '--debug'
ARGV << 'add'
ARGV << 'chrisltest'

app.parse_cli_opts


##############
# Titles and versions via the server

require 'd3/admin'

def li ; D3.cnx.connect ENV['USER'], File.read('/tmp/deleteme').chomp ; end
li

pp D3::Title.all
pp D3::Title.all :added_by, :category, :publisher, :foobar

dt = D3::Title.new name: 'MyNewTitle', admin: 'chrisl'

dt.display_name = 'My New Title'
dt.description = 'nada' # raises JSS::InvalidDataError, to short
dt.description = "This is a two line\ndescription of this title"
dt.category = 'fooo' # raises JSS::NoSuchItemError
dt.category = 'testing'
dt.make_standard
dt.make_non_standard
dt.publisher = 'MyApps.com'
dt.add_auto_groups 'asdf' # raises JSS::NoSuchItemError
dt.add_auto_groups "bingbongbeta"
dt.add_auto_groups "chrisltest"
dt.auto_groups = []
dt.add_auto_groups "chrisltest", "bingbongbeta"
dt.add_auto_groups ["chrisltest", "bingbongbeta"]
dt.remove_auto_groups "chrisltest"
dt.add_excluded_groups "chrisltest" # raises JSS::InvalidDataError:
dt.add_excluded_groups "fv2-testing", "Lion Pilot"
dt.expiration = true # JSS::InvalidDataError: Expiration must be a non-negative Integer.
dt.expiration = 12
dt.expiration_bundle_ids = 'foo/bar' # JSS::InvalidDataError: must be absolute path
dt.expiration_bundle_ids = '/foo/bar'
dt.add_expiration_path '/bar/foo'
dt.remove_expiration_path '/foo/bar'
dt.create

dt = D3::Title.fetch 'MyNewTitle'

dt.description = 'A cool thing that does cool stuff, and things.'
dt.publisher = 'foo'

dt.save

dt.delete

#######

dt2 = D3::Title.new name: 'Printalope', admin: 'chrisltest', display_name: 'Printalope'

dt2.description = "Its the Pixar Mac Printer tool\nNo Really!"

dt2.publisher = 'macback'

dt2.create

dt2.delete

#######

dt = D3::Title.fetch 'MyNewTitle'

dt.description = 'A cool thing that does cool stuff, and things.'

dt.add_auto_groups "bingbongbeta"
dt.add_auto_groups "chrisltest"

#######
dt2 = D3::Title.fetch 'Printalope'

vers = D3::Version.new admin: 'chrisl', title: 'Printalope', version: '1.0.0'

vers.create

versf = D3::Version.fetch 'Printalope', '1.0.0'

versf.minimum_os = '34324' # err
versf.minimum_os = '10.12.2'
versf.maximum_os = '10.14'

versf.remove_first = false

versf.pre_install_script = 'sdfsdf' # err
versf.pre_install_script = 'chrisltest'
versf.post_remove_script = 'chrisltest'

versf.package = '323' # err

v2 = D3::Version.new admin: 'chrisltest', title: 'MyNewTitle', version: '13.1.0a3'

v2.create

v2f = D3::Version.fetch 'MyNewTitle', '13.1.0a3'

v2fail = D3::Version.new admin: 'chrisltest', title: 'MyNewTitle', version: '13.1.0a3'

v3 = D3::Version.new admin: 'chrisltest', title: 'MyNewTitle', version: '13.1.0'

v3.create

pp D3::Version.all :status, :package_id, :pre_install_script


### pkgs

# huge array
pp D3.cnx.get 'packages/all_filenames'

# [:name, :filename, :allow_uninstalled, :reboot_required, :info, :notes, :os_requirements, :send_notification}

new_pkg_data = {
  name: 'd3v4TestPkg',
  filename: 'd3v4TestPkg-1.0.pkg',
  allow_uninstalled: true,
  info: "Informatve\non 2 lines",
  os_requirements: '>=10.13',
}
pp D3.cnx.post 'packages', new_pkg_data.to_json

pp D3.cnx.post 'packages/5859/upload', file: File.new('Desktop/net-ssh-2.9.1.gem', 'rb')
# => RestClient::BadRequest: Uploaded file must end with .pkg

pp D3.cnx.post 'packages/5859/upload', file: File.new('Desktop/net-ssh-2.9.1.gem.pkg', 'rb')
# => RestClient::BadRequest: Uploaded file is not a valid .pkg

pp D3.cnx.post 'packages/5859/upload', file: File.new('/Users/chrisl/d3roots/chrisltest-d3v4Test.pkg', 'rb')
# => {:status=>"OK", :message=>"Upload complete"}

pkg = D3.cnx.get 'packages/5859'

new_pkg_data = {
  name: 'd3v4TestPkg',
  filename: 'd3v4TestPkg-1.0.pkg',
  allow_uninstalled: true,
  info: "Informatve\non 2 lines",
  os_requirements: '>=10.13',
}

pp D3.cnx.put 'packages/5859', new_pkg_data.to_json

########## generate ssl key & cert

# generate private key
openssl genrsa -des3 -out server.key 1024

# generate cert signing req - fill out form data
openssl req -new -key server.key -out server.csr

# remove the passcode from the key (make sure its only root-readable on the server)
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key

# generate the cert from the csa
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt

# install & cleanup
mv server.crt /Library/Server/d3/config
mv server.key /Library/Server/d3/config
rm server.csr


############ Mutex & atomic write playing

require 'thread'
class Pathname

  def d3_atomic_write(data)
     # This gives a unique path to a non-existing temp file
     tmpf = Pathname.new(Dir::Tmpname.create('') { |path|  path })
     tmpf.open('w+'){ |f| f.write data }
     tmpf.rename self
  end

end

@theFile = Pathname.new '/tmp/clfile'

def one_at_a_time(text)
  @title_list_mutex ||= Mutex.new
  Thread.new do
    puts "starting thread text: #{text}"
    @title_list_mutex.synchronize do
      puts "thread #{text} has the mutex and is sleeping"
      sleep 2
      @theFile.d3_atomic_write({message: text}.to_json)
      puts "thread #{text} has updated the file and is releasing the mutex"
    end # mutex.sync
  end # Thread
end

4.times { |i| one_at_a_time i.to_s }


#
def self.generate_title_list
  @title_list_mutex ||= Mutex.new
  Thread.new do
    @title_list_mutex.synchronize do
      title_list = []
      DATA_DIR.children.each do |child|
        next unless child.basename.to_s.end_with? D3::DOT_YML
        title = YAML.load child.read
        title_list << {
          name: title.name,
          name_id: title.name_id,
          patch_source: title.patch_source,
          jss_id: title.jss_id,
          released_version: title.released_version,
          latest_version: title.latest_version
        }
      end # do |child|
      @title_list = title_list
      TITLE_LIST_FILE.d3_atomic_write all_titles.to_json
    end # mutex.sync
  end # Thread
end



########################## server notes #######################
########### SERVER: Memory-based data store with filesystem-based persistence

The server keeps 4 things in memory:

D3::Title.data_store:
# A Hash of every D3::Title instance in d3, keyed by name
#
#   {
#     'title_name' => D3::Title,
#     'title_name' => D3::Title,
#     'title_name' => D3::Title,
#     ...
#   }
#

D3::Title.json_summary_list
# A JSON Array of Hashes, one per title
# This is passed to clients when they GET the ../titles route.
#
# Each title hash has these attribute keys
#   - name: the unique name of this title in d3, only alphanumerics & _
#   - display_name: A more human-friendly, flexible name,
#   - jss_patch_source_id: the JSS::PatchSource id, which could be that of d3.
#   - jss_id: the JSS id of the title, nil if not activated in the JSS
#   - jss_name_id: the JSS name_id of the title, same as name if d3 is the source
#   - released_version: the version number of the currently live version
#   - latest_version: the version number of the latest version
#   - standard: should this title be installed on all machines automatically
#   - auto_group_ids: (array) the jss id's of computer groups that should have
#     this installed automatically
#   - excluded_group_ids: (array) the jss id's of computer groups that should
#     not be able to install this title without force


D3::Version.data_store:
# A 2-tiered Hash of every D3::Version instance in d3
#   {
#     'title_name' => {
#       'version_string' => D3::Version,
#       'version_string2' => D3::Version,
#       ...
#     }
#     'title_name' => {
#       'version_string' => D3::Version,
#       'version_string2' => D3::Version,
#       ...
#     }
#    ...
#   }


D3::Version.json_summary_list
# A JSON Array of Hashes, one per version
# This is passed to clients when they GET the ../versions route.
#
# Each title hash has these attribute keys
#   - title: the name of the title in containing this version
#   - version: the version string, unique in the title
#   - status: pilot, live, skipped, deprecated, or missing
#   - package_id: the id of the JSS package assigned to this version

When the server starts, the data stores are loaded from files on disk:

/path/to/d3server/data/dir/
  - contains all server data
/path/to/d3server/data/dir/titles/
  - contains title and version data
/path/to/d3server/data/dir/titles/XXX.yml
  - the YAML file representing D3::Title XXX
/path/to/d3server/data/dir/titles/XXX/
  - contains all the version data for D3::Title XXX
/path/to/d3server/data/dir/titles/XXX/YYY.yml
  - the YAML file representing D3::Version YYY of D3::Title XXX

When the server recieves changes to any title or version, it performs these steps
within a synchronized Mutex:
  - create/update/delete the object's yml file (atomically)
  - update/delete the object in the in-memory data_store
  - update the in-memory JSON summary list.

All data sent out from the server comes the in-memory data, or is relayed form the Jamf API. Data is never read from disk except at server startup.
