



D3 v 4  Class Structure

This structure arises from how Jamf Patch Sources work, combined with how Patch objects
and Patch Policies are structured in Jamf Pro API. For details see:

   https://www.jamf.com/jamf-nation/articles/497/jamf-pro-external-patch-source-endpoints

 and the patch-related API endpoints at

   http://developer.jamf.com/apis/jamf-pro-api/index

Classes:

Title -  the former concept of 'basename' now a class.

D3::AbstractTitle: Common code for app and server titles
  - handles all d3-specific data related to titles
  - contains @versions, a hash of D3::AbstractVersion subclass instances

D3::Server::Title: A title on the server
  - Stored on disk as YAML files
  - loaded into a threadsafe in-memory datastore on startup
  - transmitted over https as JSON (far safer - YAML has code-injection problems)

D3::Title: A title in a d3 app (d3 and d3admin)
  - defines setters & validators (for d3admin)
  - talks to the d3 server for d3-specific data
  - talks to Jamf CAPI for jss data

Version - the former concept of 'edition', now a full class, mixed with some aspects of the d3v3 D3::Package

D3::AbstractVersion: Common code for app and server titles

D3::Server::Version: A version on the  server

D3::Version: A version in a d3 app (d3 and d3admin)
  - every version has a :package_id attribute that is a reference to a JSS::Package

D3::Receipt: The former D3::Client::Receipt.
  - Will probably change a lot, and be smaller, since Jamf patch management abilities will take over some of the functionality.
  - has class methods for working with all rcpts on a client.
  - Still needed, because we want to implement features still missing in Jamf, e.g. expiration.

D3::KillApp: the former concept of 'prohibiting_process'
  - may work differently, see notes below

D3::Server::App: A sinatra-based HTTPS server with 4 purposes:
  - stores & retrieves d3-specific data about titles & versions
    This replaces the need for a MySQL table in d3v3
  - Admin and Client authentication via CAPI only. In d3v3, d3admins needed to store three
    passwords in their keychains. Now all authentication to the JSS itself is enough.

  - Eventually acts as an 'External Patch Source' for Jamf Pro. The various d3 classes will be able
    to produce the JSON data needed by the JSS. This function, with d3admin, may be
    used independently of any other aspect of D3 by anyone wanting to run a
    local patch server.
  - Acts as a webhook server, responding only to PatchSoftwareTitleUpdated events
    via 'autopilot' to add Patches to d3 automatically.
    - DO THIS? Or use Chook?  Prob simpler to do this, since its very specific

D3::Client: An 'app' object (has a 'run' method)
  - will have a wrapper executable called 'd3'
  - runs on a client to un/install, expire, sync, etc.

D3::Admin: An 'app' object (has a 'run' method)
  - will have a wrapper executable called 'd3admin'
  - manipulates D3::Titles, D3::Patches, D3::Packages,
  - Will probably NOT have a walkthru mode, but will probably have a GUI wrapper.
  - does reporting
  - freezing & piloting now done via d3admin & policies/scoping (?)

Jamf Patch :

D3::Version::Component: An element of a Patch
  -  currently only one per patch, contains Criteria defining which computers have a patch installed.

D3::Criteria & D3::Criterion: Similar to JSS::Criteriable classes, used in Titles and Versions
  - As 'requirements' in Titles
  - As 'capabilities' in Patches
    - As 'criteria' in Patch 'components'
  - see notes below

D3::ExtentionAttribute: similar to 'script' JSS::ComputerExtentionAttributes. Titles can have one or more of them
and they can be used in the criteria for the title and it's versions.
  - these have a matching JSS::ComputerExtentionAttribute, once fully accepted by the admin.






Data Store:

The server will store data as YAML files of D3 class instances.

data store directory: /Library/Servers/d3/data

contents:

 - dir: config - various server needs
   - file: config.yml - the server config file
 - dir: titles - holds title and version data
   - file: <name_id>.yml - the yaml file for the D3::Title
   - dir: <name_id> - holds the versions for a given title
       - file: <version_id>.yml - the yaml file for the D3::Version



Other Notes & thoughts:

- No longer support dmg's

- Automatic software updates on clients when new versions are released on the server
  - Patch policies do this, but they can't run scripts, see below.
  - but they have graceperiod stuff for the killapps  - re-implement?

- Pre-release piloting of new packages
 - Add some d3admin or other CLI way to do pilots via policies
   - Is this worth it? or is it OK to have devs use the web UI - check with ToolsSE
 - possibly keep the d3 pkg out of Jamf Patch Mgmt (i.e. don't make it
   appear in the Patch Source server) until its released.. ? Pilots
   would continue as they are now, possibly with some policies involved.

- Puppies - Customizable slideshow presented during logout/reboot installs
  - What does Jamf do these days or logout installs?  If its ok, alas, byebye puppies

- Installing and updating will still happen via 'jamf install' and 'jamf runScript' commands.
  Patch Policies will not be used - at least for the time being. Regular policies will be
  used for self-service, including self service notifications about updates. They will
  use the d3 client command under the hood, as they do now.

  - Regular policies still don't honor pre-script statuses, and
    Patch policies don't have an option to run scripts at all. (and the JSON is broken in the API)
    And d3's special 111 status has no equivalent anywhere.
    So - we should still do our own 'jamf runScript' and 'jamf install' commands.. but
    in that case, why bother with patch policies at all?

  - Direct jamf-ish notifications via policies could be used to get some of the user interaction
    that happens with patch policies and updates, However see RoadBlocks below. Until then -
    JamfHelper/ManagementAction/Cocoadialog/Yo

- Packages can be expired (auto-uninstalled) after a period of disuse
  - this will remain similar to how it currently works.
  - switch to one-file swift script for repoman

- Both the client and admin tools are command-line only and fully scriptable
  - yes

- Admin command-line options allow integration with developer workflows and package-retrieval tools
  - yes

- Freezing
  - works similar to now. Perhaps a better ext attr since PatchVersions can do most client reporting.

- reporting
  - available in the API now? Use Adv Searches rather than db

- autocleaning
  - as it is now.


ROADBLOCKS:

- Policy SSvc Notification data is borked in the API. see my email rant to jamf from March29th2018


Notes about Patch source JSON objects that have 'criteria' and what they mean:

  # Criteria objects
  # basically the same as JSS::Criteriable::Criterion, with the addition of
  # a 'type' value, which is either:
  #  - 'recon' for values gathered by recons, including regular ext. attributes
  #  - 'extensionAttribute' for values gathered by the special extension attribs
  #    defined by JSON extensionAttributes objects in the Patch object.


  # Software Title Objects
  #
  # 'requirements' -
  # array of criteria which define which computers in your environment may auto-
  # install patches/new versions of this title. At a minimum, they must already have
  # some version of this title installed (by any means), and these criteria are
  # how we know that's true.
  # I.e. these criteria are _required_ to be elegible for automated
  # patching/updating of this title

  # Patch (Version) Objects
  #
  # 'capabilities' -
  # array of criteria which collectively define which computers in your environment
  # may install this patch/version.
  # I.e. these criteria are indicate the computer is _capable_ of installing
  # this patch/version
  #
  # 'components' - array of ONE component object
  # Defines the installed element(s) that comprise this patch.


  # Component Objects
  #
  # 'criteria' - array of criteria
  # which collectively define which computers in your environment have
  # this *version* installed. I.e theese criteria indicate that
  # a computer has the _components_ installed that indicate this version of
  # this title.

  Heres a sample one from Bryson
  https://github.com/brysontyrrell/Patch-Starter-Script

  {
    "id": "GitHubDesktop",
    "name": "GitHub Desktop",
    "publisher": "GitHub",
    "appName": "GitHub Desktop.app",
    "bundleId": "com.github.GitHub",
    "lastModified": "2018-02-13T02:55:53Z",
    "currentVersion": "Hasty Things Done Hastily",
    "requirements": [
        {
            "name": "Application Bundle ID",
            "operator": "is",
            "value": "com.github.GitHub",
            "type": "recon",
            "and": true
        }
    ],
    "patches": [
        {
            "version": "Hasty Things Done Hastily",
            "releaseDate": "2017-05-22T20:24:33Z",
            "standalone": true,
            "minimumOperatingSystem": "10.9",
            "reboot": false,
            "killApps": [
                {
                    "bundleId": "com.github.GitHub",
                    "appName": "GitHub Desktop.app"
                }
            ],
            "components": [
                {
                    "name": "GitHub Desktop",
                    "version": "Hasty Things Done Hastily",
                    "criteria": [
                        {
                            "name": "Application Bundle ID",
                            "operator": "is",
                            "value": "com.github.GitHub",
                            "type": "recon",
                            "and": true
                        },
                        {
                            "name": "Application Version",
                            "operator": "is",
                            "value": "Hasty Things Done Hastily",
                            "type": "recon"
                        }
                    ]
                }
            ],
            "capabilities": [
                {
                    "name": "Operating System Version",
                    "operator": "greater than or equal",
                    "value": "10.9",
                    "type": "recon"
                }
            ],
            "dependencies": []
        }
    ],
    "extensionAttributes": []
}


###########
pkgutil --expand /dist/caspershare/Packages/zbrush-4.8-4.pkg /tmp/zb

## SEE ALSO the receipt related methods in cor/old/package/class_methods.rb
# extract just the PackageInfo file
/usr/bin/xar -xf /dist/caspershare/Packages/zbrush-4.8-4.pkg PackageInfo


<--  irb....
require 'rexml/document'
file = File.new( "/tmp/zb/PackageInfo" )
doc = REXML::Document.new file

doc.elements.each('pkg-info/bundle') { |bndl| puts bndl.attributes['path'] }

# get the bundle elements in an array
bundles = doc.root.elements.to_a 'bundle'
  # => [<bundle id='com.pixologic.ZHomePage' path='./Appli...

if bundles.size > 1
  puts 'This pkg installs more than one thing'
  puts 'Which one is the main application?'
  bundles.each_with_index do |bndl_elem, idx|
    puts "#{idx +1}) #{bndl_elem.attributes['path']}"
  end
  print 'Enter a number: '
  choice = gets.chomp.to_i - 1
  puts "You chose #{bundles[choice].attributes['path']}"
end
