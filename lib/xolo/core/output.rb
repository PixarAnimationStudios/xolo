# Copyright 2025 Pixar
#
#    Licensed under the Apache License, Version 2.0 (the "Apache License")
#    with the following modification; you may not use this file except in
#    compliance with the Apache License and the following modification to it:
#    Section 6. Trademarks. is deleted and replaced with:
#
#    6. Trademarks. This License does not grant permission to use the trade
#       names, trademarks, service marks, or product names of the Licensor
#       and its affiliates, except as required to comply with Section 4(c) of
#       the License and to reproduce the content of the NOTICE file.
#
#    You may obtain a copy of the Apache License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the Apache License with the above modification is
#    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#    KIND, either express or implied. See the Apache License for the specific
#    language governing permissions and limitations under the Apache License.
#

# frozen_string_literal: true

require 'io/console'

module Xolo

  module Core

    # Methods for formattng and sending output to stdout
    # Should be included in classes as needed
    #
    # NOTE: Help output is auto-generated by 'optimist'
    # The methods here are mostly for presenting info like
    # columnizd lists and reports and the like.
    module Output

      # Constants
      #############################
      #############################

      # This is used when we are not outputting to a terminal
      # usually we're being piped or not running in a terminal
      # so the lines should be as long as they want
      DEFAULT_LINE_WIDTH = 2000

      # Module methods
      #
      # These are available as module methods but not as 'helper'
      # methods in sinatra routes & views.
      #
      ##############################
      ##############################

      # when this module is included
      ##############################
      def self.included(includer)
        Xolo.verbose_include includer, self
      end

      # when this module is extended
      def self.extended(extender)
        Xolo.verbose_extend extender, self
      end

      # Instance methods
      #
      # These are available directly in sinatra routes and views
      #
      ##############################
      ##############################

      # @return [Integer] how many rows high is our terminal?
      #########################
      def terminal_height
        IO.console.winsize.first
      end

      # @return [Integer] how many columns wide is our terminal?
      #########################
      def terminal_width
        IO.console.winsize.last
      end

      # @return [Integer] how wide is our word wrap? terminal-width minus 5
      #########################
      def terminal_word_wrap
        @terminal_word_wrap ||= terminal_width - 5
      end

      # format a multi-line value by  prepending the desired indentation
      # to all but the first line, which is expected to be indented in-place where
      # its being used.
      #
      # @param value [String] the value to format
      # @param indent [Integer] the number of spaces to indent all but the first line
      # @return [String] the formatted value
      #######################
      def format_multiline_indent(value, indent:)
        value = value.to_s
        return value unless value.include? "\n"

        lines = value.split("\n")
        lines[1..-1].each { |line| line.prepend ' ' * indent }
        lines.join("\n")
      end

      # Display a list of items in as many columns as possible
      # based on terminal width, e.g. with 3 cols:
      #
      #   a thing        another thing    third thing
      #   thing2         line2 thing      third line 2
      #   line3 thing    another one      and yet a 3rd
      #   oh my line4    4 line ok?       yes, this is it
      #
      # and if the list is longer than terminal height,
      # pipe it through 'less'
      #
      # @param header [String] A string to display at the top prepended with a '#'
      #    and appended with a newline and a line of ######'s of the same length.
      #
      # @param list [Array<String>] the items to list
      #
      # @return [void]
      ############################
      def list_in_cols(header, list)
        longest_list_item = list.map(&:size).max
        use_columns = (longest_list_item + 5) < terminal_width

        list_to_display = use_columns ? highline_cli.list(list, :columns_down) : list.join("\n")

        output = +"# #{header}\n"
        output << '#' * (terminal_width - 5)
        output << "\n"
        output << list_to_display

        show_text output
      end

      # Generate a report of rowed/columned data, either fixed-width or tab-delimited.
      #
      # Title and header lines are pre-pended with '# ' for easier exclusion
      # when using the report as input for some other program.
      # If the :type is :fixed, so will the column header line.
      # (however, for parsing this data, try using the --json option)
      #
      # @param lines [Array<Array>] the rows and columns of data
      #
      # @param type [Symbol] :fixed or :tab, defaults to :fixed
      #
      # @params title [String] a descriptive text or title, shown above the
      #   column headers. Every line is pre-pended with '# '.
      #   Only used on :fixed reports.
      #
      # @params header_row [Array<String>] the column headers. optional.
      #
      # @return [String] the formatted report.
      #
      ############################
      def generate_report(lines, type: :fixed, header_row: [], title: nil)
        return Xolo::BLANK if lines.pix_empty?

        raise ArgumentError, 'The first argument must be an Array' unless lines.is_a?(Array)
        raise ArgumentError, 'The header_row must be an Array' unless header_row.is_a? Array

        # tab delim is easy
        if type == :tab
          report_tab = header_row.join("\t")
          lines.each { |line| report_tab += "\n#{line.join("\t")}" }
          return report_tab.strip
        end # if :tab

        # below here, fixed width

        line_width, format_str = width_and_format(lines, header_row)

        # title if given
        report = title ? +"# #{title}\n" : +''

        unless header_row.empty?
          unless header_row.size == lines[0].size
            raise ArgumentError,
                  "Header row must have #{lines[0].count} items"
          end

          # then the header line if given
          report +=  format_str % header_row
          # add a separator
          report +=  '#' + ('-' * (line_width - 1)) + "\n"
        end
        # add the rows
        lines.each { |line| report += format_str % line }

        report
      end # generate report

      # Given an Array of Arrays representing rows and columns of data,
      # figure out the appropriate line-width for the longest line
      # and the printf format string to create the columns
      #
      #
      # @param lines [Array<Array>] The rows and columns of data
      #
      # @param header_row [Array] An optional header row to include in the
      #   width calculation.
      #
      # @return [Array<Integer, String>] the line width and format string
      #
      ############################
      def width_and_format(lines, header_row = [])
        # below here, fixed width
        format_str = +''
        line_width = 0
        header_row[0] = "# #{header_row[0]}"

        col_widths(lines, header_row).each do |w|
          # make sure there's a space between columns
          col_width = w + 1

          # add the column to the printf format
          format_str += "%-#{col_width}s"
          line_width += col_width
        end
        format_str += "\n"

        # if needed, limit the total line width for the header the width of the terminal
        max_width = $stdout.tty? ? terminal_word_wrap : DEFAULT_LINE_WIDTH
        line_width = max_width if line_width > max_width

        [line_width, format_str]
      end

      # Given an Array of Arrays representing rows and columns of data
      # figure out the widest width of each column and return an array
      # of integers representing those widths
      #
      # @param data [Array<Array>] The rows and columns of data
      #
      # @param header_row [Array] An optional header row to include in the
      #   width calculation.
      #
      # @return [Array<Integer>] the max widths of each column of data.
      #
      ############################
      def col_widths(data, header_row = [])
        widths = header_row.map { |c| c.to_s.length }
        data.each do |row|
          row.each_index do |col|
            this_width = row[col].to_s.length
            widths[col] = this_width if this_width > widths[col].to_i
          end # do field
        end # do line
        widths
      end

      # Should a given string be displayed via /usr/bin/less?
      # true if stdout is a tty AND the string is > (terminal height - 2)
      # The - 2 accounts for the final newline and an extra line at the
      # bottom of the terminal, for better visual results
      #########################
      def use_less?(text)
        $stdout.tty? && text.lines.size > (terminal_height - 2)
      end

      # Send a string to the terminal, possibly piping it through 'less'
      # if the number of lines is greater than the number of terminal lines
      #
      # @param text[String] the text to send to the terminal
      #
      # @param show_help[Boolean] should the text have a line at the top
      #   showing basic 'less' key commands.
      #
      # @result [void]
      #
      ############################
      def show_text(text, show_help = true)
        unless use_less?(text)
          puts text
          return
        end

        if show_help
          help = "# -- Using /usr/bin/less: ' ' next, 'b' prev, 'q' exit, 'h' help --"
          text = "#{help}\n#{text}"
        end

        # point stdout through less, print, then restore stdout
        less = IO.popen('/usr/bin/less', 'w')

        begin
          less.puts text

        # this catches the quitting of 'less' before all the output
        # is displayed
        rescue Errno::EPIPE
          true
        ensure
          less&.close
        end
      end

    end

  end

end # module
